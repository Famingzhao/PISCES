---
title: "PISCES Walkthrough"
authors: "Lukas Vlahos, Pasquale Laise, Andrea Califano"
correspondence: "Pasquale Laise  and Andrea Califano"
contacts: lv2395@cumc.columbia.edu, pl2959@cumc.columbia.edu, ac2248@cumc.columbia.edu.
output: html_document
fig_align: 'center'
---

### Introduction

The pipeline for Protein Activity Inference in Single Cells (PISCES) is a regulatory-network-based methdology for the analysis of single cell gene expression profiles.

PISCES transforms highly variable and noisy single cell gene expression profiles into robust and reproducible protein activity profiles and is centered around two key algorithms: the Algorithm for the Reconstruction of Accurate Cellular Networks ARACNe [1]; and the algorithm for  Virtual Inference of Protein-activity by Enriched Regulon analysis (VIPER/metaVIPER) [2,3].

Briefly, the ARACNe  algorithm is  one of the most widely used methods for inferring transcriptional interactions from gene expression data. The VIPER algorithm uses the expression of the ARACNe-inferred regulatory targets of a given protein, such as the targets of a transcription factor (TF), as an accurate reporter of its activity. Typically, PISCES  can accurately assess the activity of up to 6000 regulatory proteins  from single cell gene expression profiles,  significantly increasing the ability to analyze the biological function and relevance of gene products whose mRNAs are undetectable in individual cells (e.g. dropout effect).

As currently designed, this pipeline requires a moderate level of computer science know-how. Access to cluster architecture is also advised, as computing networks on a single-core is  time consuming.

### Setup

To run this pipeline, you'll need to have the following packages installed:

* viper
* cluster
* ggplot2
* ggpubr
* umap
* pheatmap
* RColorBrewer
* Matrix
* biomaRt
* psych

```{r include = FALSE}
setwd('C://Users/lvlah/linux/ac_lab/single-cell-pipeline/')
r1.pAct <- readRDS('tutorial/pbmc_r1-pAct.rds')
r2.pAct <- readRDS('tutorial/pbmc_r2-pAct.rds')
```

**NOTE:** This walkthrough will assume that you've set your working directoy to a folder containing the PISCES repo, and that all saved data will be deposited in the same directory. This is not recommended for practical use, and can be changed by specifying full paths when loading or saving in your own applications. 

Start by loading in the PISCES functions as well as the provided test data. Note that this pipeline uses ENSMBL Gene IDs by default:

```{r}
source('functions/process-utils.R')
source('functions/cluster-functions.R')
source('functions/viper-utils.R')
library(ggplot2)
library(ggpubr)
library(viper)
library(pheatmap)
library(RColorBrewer)
raw.mat <- readRDS('tutorial/pbmc.rds')
```

Alternatively, if your data is still in 10x format, you can read it in this manner (you don't need to run this for the purpose of the tutorial):

```{r eval = FALSE}
library(Matrix)
raw.mat <- as.matrix(readMM('data/matrix.mtx'))
genes <- read.table('data/genes.tsv', sep = '\t')
barcodes <- read.table('data/barcodes.tsv', sep = '\t')
colnames(raw.mat) <- barcodes[,1]
rownames(raw.mat) <- genes[,1]
```

We recommend saving intermediate data at each step, since many of these steps will take a considerable amount of time with an average sized single cell data set. These saving steps are not including in this walkthrough, but can be achieved with the saveRDS function in R.

### PreProcessing

First, we perform some cursory QC on the data to check the distribution of read depth and genes detected in each sample:

```{r, fig.align = 'center', fig.width = 9, fig.height = 5}
QCPlots(raw.mat)
```

This QC analysis should inform subsequent filtration steps. By default, we remove any genes with no counts, as well as any samples that have too few (< 1000) or too many (> 100000) UMIs. These thresholds can be adjusted using the arguments of the QCTransform function based on your data. Once the data is filtered, we will apply a CPM normalization, then generate a gene expression signature using a double rank transformation.

```{r}
filt.mat <- QCTransform(raw.mat)
cpm.mat <- CPMTransform(filt.mat)
rank.mat <- RankTransform(cpm.mat)
```

By default gene expression signature is generated using a "double rank" approach, which uses the median gene expression of the data set as an internal reference to compute a gene expression signature on a cell by cell basis.

### R1 Network Generation

**NOTE:** Because ARACNe takes a considerable amount of time to run, we recommend setting up a cluster-based implementation. For ease-of-use in this tutorial, we have included the networks generated in this analysis within the tutorial, so that you do not need to generate them yourself. We encourage you to still read and understand this section, but you can also skip directly to **R1 Clustering**.

For a detailed tutorial on how to use ARACNe-AP, consult the github here: https://github.com/califano-lab/ARACNe-AP/blob/master/README.md

The default PISCES approach assumes that there are no known cell type labels in the data set. PISCES will generate an ARACNe network from all the cells that will not capture cell type specific regulatory structure but will be able to separate broad cell populations. If the data set contains multiple labeled cell types (e.g. experimentally defined by FACscell-type specific networks can be generated based on those labels. However, we recommend proceeding in an unsupervised manner, as the unsupervised analysis can confirm the experimental design and, potentially, generate novel biological findings.

The data must first be saved in a foramt that is compatible with the Java based ARACNe-AP implementation included in this pipeline:

```{r eval = FALSE}
ARACNeTable(cpm.mat, 'tutorial/pbmc-cpm.tsv')
```

ARACNe should be run for each regulator set (TFs, COTFs, and Signaling Proteins). The files containing the lists of the candidate master regulator proteins can be found in the */Modules/ARACNe/* directory for both mouse and human data. Once ARACNe has generated .tsv's for each of these regulator sets, the .tsv's should be merged, which can be done through the command line. Finally, the merged .tsv's can be combined with the original data to create a VIPER compatible network with the following command:

```{r eval = FALSE}
RegProcess('tutorial/pbmc_r1-net-final.tsv', cpm.mat, out.dir = 'tutorial/', out.name = 'pbmc_r1-net-')
```

### R1 Clustering

Once the ARACNe network has been generated, we  can infer protein activity as following:

```{r eval = FALSE}
r1.net <- readRDS('tutorial/pbmc_r1-net-pruned.rds')
r1.pAct <- viper(rank.mat, r1.net, method = 'none')
```

Single-cell ARACNe networks usually contain fewer regulons than those generated from bulk data due to data sparsity, and the number of regulators for which VIPER can infer protein activity is therefore lower. To counteract this, ARACNe networks generated from tissue-specific bulk samples available in the GTEx database are provided for additional inference. In this optional step, the most appropriate GTEx networks will be selected for your data, and metaVIPER will be performed using those networks. Then, any regulators for which activity can be inferred from the bulk networks but not from the single-cell networks will be incoporated into the *r1.pAct* object. This will allow for a more complete interpretation of the data in downstream analyses.

**NOTE:** for the purposes of this pipeline, this is an optional step that you do not have to run. Because this step is generating VIPER matrices from more than 30 networks, it will take a considerable amount of time and memory to run. We recommend running this step on a cluster system with 32GB of memory or more allocated for any data set with 1000 or more cells. Finally, this step is not relevant for murine data, as the GTEx networks are generated from human RNAseq.

```{r eval = FALSE}
r1.gtex <- GTExVIPER(r1.pAct, 'GTEx-Nets/')
r1.pAct <- ViperMerge(r1.pAct, r1.gtex)
```

Once the protein activity has been computed, clustering analysis can be performed on the protein activity-based distance metrix. This pipeline uses *viperSimilarity* as a distance metric and the *PAM* algorithm for clustering, but other methods such as K-Means or louvain can be applied:

```{r, fig.align = 'center'}
r1.viperDist <- as.dist(viperSimilarity(r1.pAct))
r1.clusts <- PamKRange(r1.viperDist, kmin = 2, kmax = 10)
r1.clustSil <- SilScoreEval(r1.clusts, r1.viperDist)
plot.dat <- data.frame('k' = 2:10, 'Silhouette.Scores' = r1.clustSil)
ggplot(plot.dat, aes(x = k, y = Silhouette.Scores)) + geom_point() + geom_line() +
  ggtitle('R1 Clustering Silhouette Scores')
```

This will generate a set of clusterings for values of *k* between 2 and 5, then generate a vector of average silhouette scores that indicate cluster quality. A plot of the silhouette scores can be automatically saved by using the optional *plotPath* argument with the *SilScoreEval* function. For the data set used in this tutorial, the optimal clustering occured with *k=3*, as defined by the maximum silhouette score. A silhouette score of 0.25 or above is generalyl considered robust [4, 5]. (Note that in other analyses, the optimal number of clusters will be different.) This clustering will now be used to generate cluster-specific ARACNe networks.

In order to improve the quality of the clus ARACNe networks, PISCES transforms single cell gene expression profiles into metacell profiles. The PISCES meta-cell inference algorithm aims at overcoming the sparse nature of single cell data due to dropouts (inefficient mRNA capture) by integrating the expression profiles of local cell clusters that have similar protein activity profiles. This is accomplished by generating a K-nearest neighbor (KNN) graph based on the *viperSimilarity* distance method, then summing neighborhoods of ten cells. Metacells generated within each cluster are subset to 200 to avoid significant overlap. All of these steps can be accomplished with the following command (if you are interested in running these steps seperately in your analysis, there are also stand alone commands for each):

```{r eval = FALSE}
r1.clustMats <- MakeCMfA(filt.mat, r1.viperDist, clustering = r1.clusts$k3, out.dir = 'tutorial', out.name = 'pbmc-r1-clusts')
```

### R2 Network Generation

**NOTE:** NOTE: As in the **R1 Network Generation** step, we have  included the ARACNe networks generated in this step within the tutorial. 


The procedure for this step is the same as in **R1 Network Generation**, but must be repeated for each cluster generated in the **R1 Clustering** step. 

```{r eval = FALSE}
c1.net <- RegProcess('tutorial/r2-nets/pbmc-r2-c1_finalNet.tsv', r1.clustMats[[1]], 
                     out.dir = 'tutorial/r2-nets/', out.name = 'pbmc-r2-c1_')
c2.net <- RegProcess('tutorial/r2-nets/pbmc-r2-c2_finalNet.tsv', r1.clustMats[[2]], 
                     out.dir = 'tutorial/r2-nets/', out.name = 'pbmc-r2-c2_')
c3.net <- RegProcess('tutorial/r2-nets/pbmc-r2-c3_finalNet.tsv', r1.clustMats[[3]], 
                     out.dir = 'tutorial/r2-nets/', out.name = 'pbmc-r2-c3_')
```

### R2 Clustering

The cell-type specific networks can now be used to infer a more robust protein activity profile and clustering scheme. The procedure is the same as the **R1 Clustering** step; a protein activity profile is inferred with VIPER, then clusters are identified using *viperSimilarity* adn *PAM*:

```{r eval = FALSE}
# load in networks
c1.net <- readRDS('tutorial/pbmc-r2-c1_pruned.rds')
c2.net <- readRDS('tutorial/pbmc-r2-c2_pruned.rds')
c3.net <- readRDS('tutorial/pbmc-r2-c3_pruned.rds')
# infer protein activity
r2.pAct <- viper(rank.mat, list('c1' = c1.net, 'c2' = c2.net, 'c3' = c3.net), method = 'none')
```

```{r, fig.align = 'center'}
# generate clusterings
r2.viperDist <- as.dist(viperSimilarity(r2.pAct))
r2.clusts <- PamKRange(r2.viperDist, kmin = 2, kmax = 15)
r2.clustSil <- SilScoreEval(r2.clusts, r2.viperDist)
plot.dat <- data.frame('k' = 2:15, 'Silhouette.Scores' = r2.clustSil)
ggplot(plot.dat, aes(x = k, y = Silhouette.Scores)) + geom_point() + geom_line() +
  ggtitle('R2 Clustering Silhouette Scores')
```

In the final step, PISCES computes a protein acitivity signature of each cluster of cells. In the data set used in this tutorialx *k=2* is the optimal clustering based on the silhouette score, but, as before, each data set will be different. As a pre-processing step, we convert form ENSG to gene names for ease of interpretation in downstream biological analyses:

```{r}
r2.pAct <- Ensemble2GeneName(r2.pAct)
r2Clust.mrs <- GetMRs(r2.pAct, clustering = r2.clusts$k2$clustering, method = 'Stouffer', numMRs = 50, bottom = FALSE, weights = r2.clusts$k2$silinfo$widths[,3])
```

### Visualization Schemes

Because protein activity data is very high-dimensional (2000+), we recommend visualization using a heatmap. In particular, a heatmap of the cluster specific master regulators will show how the most significant proteins in the clustering differ between clusters. As a warning, if you're using RStudio, make sure that the R graphic window size is large enough to display the plot:

```{r, fig.height = 8, fig.width = 6, fig.align = 'center'}
ClusterHeatmap(r2.pAct[ MR_UnWrap(r2Clust.mrs) , ], clust = r2.clusts$k2$clustering, plotTitle = 'R2 Clustering: k = 2')
```

While 2D visualization does not present as much information as a heatmap showing all proteins, it is a more inuitive format in which to present data, particularly for traditional biologists. A Uniform Manifold Approximation and Projection (UMAP) is used to perform a dimensionality reduction, first by filtering the data to look at the most important master regulators on a cell-specific basis, then using these features as input to the UMAP algorithm:

```{r, fig.align = 'center'}
dat.umap <- cbcMR_UMAP(r2.pAct)
ClusterUMAP(r2.clusts$k2$clustering, dat.umap, 'R2 Clustering: k = 2')
```

### Iterative Clustering

Many single-cell data sets will contain a wide variety of populations that are not equidistant. For instance, it will be much easier to separate epithelial cells and T-Cells then it will be to seperate CD4 and CD8 populations of T-Cells. Because of this, the first iteration of PAM will often contain large clusters of cells that are actually a combination of two smaller but distinct populations.

To identify these biologically relevant subclusters, we have implemented the *IterPAM* function. This function will perform an iterative clustering analysis, identifying subclusters that pass a given silhouette score threshold (0.25 by default). The parameters of this function will need to be tuned to your dataset - for instance, a more heterogeneous data set will require more iterations to reveal all subclusters, which ca be changed with the *iter.max* parameter. Different distance funtionc an also be used, though we recommend the method below if you plan to use protein activity data:

```{r}
dist.func <- function(x) { as.dist(viperSimilarity(x)) }
r2.iClust <- IterPAM(r2.pAct, dist.func)
```

We can visualize this clusteringas in **R2 Clustering**, but with a more detailed annotation that highlights the iterative clustering procedure (annotation of the subclusters):

```{r, fig.height = 8, fig.width = 6, fig.align = 'center'}
iClust.mrs <- GetMRs(r2.pAct, clustering = r2.iClust$clustering[,5], method = 'Stouffer', numMRs = 50, bottom = FALSE)
annot.col <- data.frame(r2.iClust$clustering)
for(i in 1:ncol(annot.col)) { annot.col[,i] <- as.factor(annot.col[,i]) }
pheatmap(r2.pAct[ MR_UnWrap(iClust.mrs) , rownames(annot.col) ], scale = 'row', annotation_col = annot.col,
         color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), height = 8, width = 6,
         cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = FALSE,
         main = 'R2 Protein Activity Iterative Clustering')
```

A UMAP plot can also be produced in the same manner as above:

```{r, fig.align = 'center'}
ClusterUMAP(r2.iClust$clustering[,5], dat.umap, 'R2 IterClust: i = 5')
```

### Superimposing Markers

The clusters generated by this pipeline are totally unsupervised. However, the user can superimpose a set of specific markers for clustering analysis. These clusters will provide specific information about the activity of these markers across all the cells:

```{r, fig.height = 7, fig.width = 15, fig.align = 'center'}
clust <- r2.iClust$clustering[,2]
plot.dat <- data.frame('UMAP1' = dat.umap$layout[,1], 'UMAP2' = dat.umap$layout[,2])
plot.dat[['cluster']] <- as.factor(clust[rownames(dat.umap$layout)])
clusters <- ggplot(plot.dat, aes(x=UMAP1, y=UMAP2, color=cluster)) + geom_point() + ggtitle('Clusters')

plot.dat[['CCR7']] <- scale(as.numeric(r2.pAct['CCR7',]))
CCR7 <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = CCR7)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('CCR7')
plot.dat[['CD8A']] <- scale(as.numeric(r2.pAct['CD8A',]))
CD8A <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = CD8A)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('CD8A')
plot.dat[['MS4A1']] <- scale(as.numeric(r2.pAct['MS4A1',]))
MS4A1 <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = MS4A1)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('MS4A1')
plot.dat[['PPBP']] <- scale(as.numeric(r2.pAct['PPBP',]))
PPBP <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = PPBP)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('PPBP')
plot.dat[['MS4A7']] <- scale(as.numeric(r2.pAct['MS4A7',]))
MS4A7 <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = MS4A7)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('MS4A7')
plot.dat[['IL7R']] <- scale(as.numeric(r2.pAct['IL7R',]))
IL7R <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = IL7R)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('IL7R')
plot.dat[['CD14']] <- scale(as.numeric(r2.pAct['CD14',]))
CD14 <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = CD14)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('CD14')
plot.dat[['FCER1A']] <- scale(as.numeric(r2.pAct['FCER1A',]))
FCER1A <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = FCER1A)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('FCER1A')
plot.dat[['FCGR3A']] <- scale(as.numeric(r2.pAct['FCGR3A',]))
FCGR3A <- ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(colour = FCGR3A)) + 
  scale_colour_gradientn(colours = c('blue', 'white', 'red')) + ggtitle('FCGR3A')

marker.plot <- ggarrange(clusters, CCR7, CD8A, MS4A1, PPBP, MS4A7, IL7R, CD14, FCER1A, FCGR3A, ncol = 5, nrow = 2)
print(annotate_figure(marker.plot, top = text_grob('R2 Iterclust (i = 2) w/ Canonical PBMC Markers', size = 24)))
```


### References

1.	Lachmann, A., et al., *ARACNe-AP: gene network reverse engineering through adaptive partitioning inference of mutual information*. Bioinformatics, 2016. 32(14): p. 2233-5.  
2.	Califano, H.D.a.A., *iterClust: Iterative Clustering*. R package version 1.4.0. 2018: https://github.com/hd2326/iterClust.  
3.	Ding, H., et al., *Quantitative assessment of protein activity in orphan tissues and single cells using the metaVIPER algorithm*. Nat Commun, 2018. 9(1): p. 1471.  
4.  Rosseeuw, P.J., *Journal of Computational and Applied Mathematics* 20 (1987) 53-65  
5.  Izenman, A.J., *Modern Multivariate Statistical Techniques. Regression, Classification, and Manifold Learning*. Springer text in statistics, 2008 (Chapter 12)

#### Acknowledgements

Jeremy Dooley - for his advice and expertise in single cell sequencing experiments.  
Hongxu Ding - whose work in the Califano laid the groundwork for the development of this pipeline.  
Evan Paull - for help with software and tutorial development and testing.

