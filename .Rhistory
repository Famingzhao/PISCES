annot.df <- data.frame('phi' = sort(phiVals[1,]))
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:50] , names(sort(phiVals[1,])) ], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
?pheatmap
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:75] , names(sort(phiVals[1,])) ], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize = 4,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
row.df <- data.frame('correlation' = pAct.phiCorr[1:50])
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:75] , names(sort(phiVals[1,])) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 4,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
row.df <- data.frame('correlation' = abs(pAct.phiCorr[1:50]))
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:75] , names(sort(phiVals[1,])) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 4,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
annot.df <- data.frame('phi' = sort(phiVals[1,]))
row.df <- data.frame('corr' = abs(pAct.phiCorr[1:50]))
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:75] , names(sort(phiVals[1,])) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 4,
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
annot.df <- data.frame('clust' = as.factor(r1.clust$k2$clustering[names(sort(phiVals[1,]))]),
'phi' = sort(phiVals[1,]))
pheatmap(r1.pAct[markers,names(sort(phiVals[1,]))], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
annot.df <- data.frame('clust' = as.factor(r1.clust$k2$clustering[names(sort(phiVals[1,]))]),
'phi' = sort(phiVals[1,]))
pheatmap(r1.pAct[markers,names(sort(phiVals[1,]))], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
stroma.net <- get(load('C://Users/lvlah/linux/ac_lab/data/lcm_pda/regul_stroma.rda'))
stroma.net.pruned <- pruneRegulon(stroma.net, 50, adaptive = FALSE, eliminate = TRUE)
epi.net <- get(load('C://Users/lvlah/linux/ac_lab/data/lcm_pda/regul_epith.rda'))
epi.net.pruned <- pruneRegulon(epi.net, 50, adaptive = FALSE, eliminate = TRUE)
hugo.names <- readRDS("C://Users/lvlah/linux/ac_lab/Hugo.Names.rds")
############################
stroma.mrs <- readRDS('C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_stroma_msViper.rds')
epi.mrs <- readRDS('C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_epi_msViper.rds')
stroma.vip <- readRDS('C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_stroma_viper.rds')
epi.vip <- readRDS('C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_epi_viper.rds')
metadata <- read.table('C://Users/lvlah/linux/ac_lab/data/lcm_pda/PDAC-Interactome-Samples_newOk.txt',
header = TRUE, sep = '\t')
############################
### generate correlation model(s) between stroma and epi compartments in lcm ###
## sync up IDs
stroma.patients <- metadata$PatientID[ match(colnames(stroma.vip), metadata$SampleID) ]
epi.patients <- metadata$PatientID[ match(colnames(epi.vip), metadata$SampleID) ]
shared.patients <- intersect(stroma.patients, epi.patients)
stroma.meta <- metadata[ which(metadata$Compartment == 'Stroma') ,]
matched.stromaID <- stroma.meta$SampleID[ match(shared.patients, stroma.meta$PatientID) ]
epi.meta <- metadata[ which(metadata$Compartment == 'Epithelium') ,]
matched.epiID <- epi.meta$SampleID[ match(shared.patients, epi.meta$PatientID) ]
length(matched.stromaID)
length(matched.epiID)
stroma.vip <- stroma.vip[, as.character(matched.stromaID) ]
epi.vip <- epi.vip[, as.character(matched.epiID) ]
## change to hugo gene names
rownames(stroma.vip) <- hugo.names[ rownames(stroma.vip) ]
rownames(epi.vip) <- hugo.names[ rownames(epi.vip) ]
## create the design matrix for the MMR model
stroma.MRmat <- stroma.vip[ intersect(names(sort(stroma.mrs$es$nes, decreasing = TRUE))[1:100], rownames(stroma.vip)) ,]
rownames(stroma.MRmat) <- paste('S.', rownames(stroma.MRmat), sep = '')
epi.MRmat <- epi.vip[ intersect(names(sort(epi.mrs$es$nes, decreasing = TRUE))[1:100], rownames(epi.vip)) ,]
rownames(epi.MRmat) <- paste('E.', rownames(epi.MRmat), sep = '')
design.mat <- rbind( stroma.MRmat , epi.MRmat )
design.mat <- t(design.mat)
## fit MMR model
dvs <- paste(colnames(design.mat)[1:100], collapse = ' + ')
ivs <- paste(colnames(design.mat)[101:ncol(design.mat)], collapse = ' + ')
model.formula <- as.formula(colnames(design.mat)[1:100] ~ ivs)
mmr.model <- lm(design.mat[, 1:100] ~ design.mat[, 101:ncol(design.mat)])
saveRDS(mmr.model, 'C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_model_fit.rds')
### find single-cell distances using the bulk linear model ###
sc.pda <- readRDS('C://Users/lvlah/linux/ac_lab/data/singleCell/all/pdac-allPatients-geneExp.rds')
sc.metaData <- read.csv('C://Users/lvlah/linux/ac_lab/data/singleCell/all/metadata.csv', header = TRUE, row.names = 1)
View(sc.metaData)
ht150.samps <- rownames(sc.metaData)[which(sc.metaData$ID == 'HT150')]
ht150.samps
table(scsc.metaData$ID)
table(sc.metaData$ID)
ht150.samps <- rownames(sc.metaData)[which(sc.metaData$ID == 'HT143')]
ht143.pda <- sc.pda[, ht143.samps]
ht143.samps <- rownames(sc.metaData)[which(sc.metaData$ID == 'HT143')]
ht143.pda <- sc.pda[, ht143.samps]
dim(ht143.samps)
dim(ht143.pda
)
patient <- 'HT103'
pat.samps <- rownames(sc.metaData)[which(sc.metaData$ID == patient)]
pat.pda <- sc.pda[, pat.samps]
rm(ht143.pda)
dim(pat.pda)
## split the matrix into epithelial and stromal compartments
pat.eCells <- get(load('C://Users/lvlah/linux/ac_lab/data/cancerCellNames/names_cancer_cells_PDA_103.rda'))
ppat.eCells
pat.eCells
### find single-cell distances using the bulk linear model ###
source('C://Users/lvlah/linux/ac_lab/single-cell-pipeline/functions/process-utils.R')
QCPlots(pat.pda)
pat.filt <- QCTransform(pat.pda)
pat.cpm <- CPMTransform(pat.filt)
pat.epi <- pat.cpm[, intersect(pat.eCells, colnames(pat.cpm)) ]
dim(pat.epi)
length(pat.eCells)
pat.stroma <- pat.cpm[, setdiff(colnames(pat.cpm), pat.eCells) ]
dim(pat.stroma)
pat.epiRank <- RankTransform(pat.epi)
pat.stromaRank <- RankTransform(pat.stroma)
pat.epiVip <- viper(pat.epiRank, regulon = epi.net.pruned, method = 'none')
pat.stromaVip <- viper(pat.stromaRank, regulon = stroma.net.pruned, method = 'none')
rownames(pat.epiRank)
rownames(stroma.vip)
epi.net.pruned
names(epi.net.pruned)
convert.dict <- readRDS('C://Users/lvlah/linux/ac_lab/data/gene-convert-dict.rds')
View(convert.dict)
length(which(rownames(sc.pda) %in% convert.dict$Entrez.Gene.ID))
rownames(sc.pda)
length(which(rownames(sc.pda) %in% convert.dict$Ensembl.Gene.ID))
length(which(rownames(pat.cpm) %in% convert.dict$Ensembl.Gene.ID))
dim(pat.cpm)
## convert gene names to entrez
pat.cpm <- pat.cpm[ which(rownames(pat.cpm) %in% convert.dict$Ensembl.Gene.ID) ,]
dim(pat.cpm)
match(rownames(pat.cpm), convert.dict$Ensembl.Gene.ID)
rownames(pat.cpm) <- convert.dict$Entrez.Gene.ID[ match(rownames(pat.cpm), convert.dict$Ensembl.Gene.ID) ]
rownames(pat.cpm)
pat.cpm <- pat.cpm[ which(rownames(pat.cpm) %in% convert.dict$Ensembl.Gene.ID) ,]
rownames(pat.cpm) <- convert.dict$Entrez.Gene.ID[ match(rownames(pat.cpm), convert.dict$Ensembl.Gene.ID) ]
## split the matrix into epithelial and stromal compartments
pat.eCells <- get(load('C://Users/lvlah/linux/ac_lab/data/cancerCellNames/names_cancer_cells_PDA_103.rda'))
pat.epi <- pat.cpm[, intersect(pat.eCells, colnames(pat.cpm)) ]
pat.stroma <- pat.cpm[, setdiff(colnames(pat.cpm), pat.eCells) ]
pat.epiRank <- RankTransform(pat.epi)
pat.stromaRank <- RankTransform(pat.stroma)
## viper inference using bulk networks
pat.epiVip <- viper(pat.epiRank, regulon = epi.net.pruned, method = 'none')
pat.stromaVip <- viper(pat.stromaRank, regulon = stroma.net.pruned, method = 'none')
pat.cpm <- CPMTransform(pat.filt)
## convert gene names to entrez
pat.cpm <- pat.cpm[ which(rownames(pat.cpm) %in% convert.dict$Ensembl.Gene.ID) ,]
rownames(pat.cpm) <- convert.dict$Entrez.Gene.ID[ match(rownames(pat.cpm), convert.dict$Ensembl.Gene.ID) ]
## split the matrix into epithelial and stromal compartments
pat.eCells <- get(load('C://Users/lvlah/linux/ac_lab/data/cancerCellNames/names_cancer_cells_PDA_103.rda'))
pat.epi <- pat.cpm[, intersect(pat.eCells, colnames(pat.cpm)) ]
pat.stroma <- pat.cpm[, setdiff(colnames(pat.cpm), pat.eCells) ]
pat.epiRank <- RankTransform(pat.epi)
pat.stromaRank <- RankTransform(pat.stroma)
## viper inference using bulk networks
pat.epiVip <- viper(pat.epiRank, regulon = epi.net.pruned, method = 'none')
pat.stromaVip <- viper(pat.stromaRank, regulon = stroma.net.pruned, method = 'none')
## subset scVip matrices to MRs from LCM
pat.epiMR <- pat.epiVip[ rownames(stroma.MRmat) ,]
rownames(pat.stromaVip) <- hugo.names[ rownames(pat.stromaVip) ]
rownames(pat.epiVip) <- hugo.names[ rownames(pat.epiVip) ]
## subset scVip matrices to MRs from LCM
pat.epiMR <- pat.epiVip[ rownames(stroma.MRmat) ,]
dim(pat.epiVip)
intersect(rownames(stroma.MRmat), rownames(pat.epiVip))
rownames(stroma.MRmat)
rownames(pat.stromaVip) <- paste('S', rownames(pat.stromaVip), sep = '.')
rownames(pat.epiVip) <- paste('E', rownames(pat.epiVip), sep = '.')
rownames(pat.stromaVip)
intersect(rownames(stroma.MRmat), rownames(pat.epiVip))
intersect(rownames(stroma.MRmat), rownames(pat.stromaVip))
pat.stromaMR <- pat.stromaVip[ rownames(stroma.MRmat) ,]
pat.epiMR <- pat.epiVip[ rownames(epi.MRmat) ,]
## predict using the LCM MMR model
predict.stroma <- predict(mmr.model, t(pat.epiMR))
## predict using the LCM MMR model
predict.stroma <- predict(mmr.model, as.data.frame(t(pat.epiMR)) )
mmr.model
as.data.frame(t(pat.epiMR))
dim(as.data.frame(t(pat.epiMR)))
mmrmmr.model
mmr.model
dim(mmr.model$coefficients)
?predict
## predict using the LCM MMR model
predict.stroma <- predict(mmr.model, newdata = as.data.frame(t(pat.epiMR)) )
## predict using the LCM MMR model
predict.stroma <- predict.lm(mmr.model, newdata = as.data.frame(t(pat.epiMR)) )
?fitted
fitted(mmr.model)
View(mmr.model$coefficients)
cbind( as.matrix(rep(1, ncol(pat.epiMR))) , t(pat.epiMR) )
View(cbind( as.matrix(rep(1, ncol(pat.epiMR))) , t(pat.epiMR) ))
## predict using the LCM MMR model
predict.stroma <- cbind( as.matrix(rep(1, ncol(pat.epiMR))) , t(pat.epiMR) ) %*% as.matrix( mmr.model$coefficients )
dim(predict.stroma)
rownames(predict.stroma) <- colnames( pat.epiMR )
colnames(predict.stroma) <- rownames( mmr.model$coefficients )
View(predict.stroma)
colnames(predict.stroma) <- colnames( mmr.model$coefficients )
View(predict.stroma)
## infer pairwise distances
infer.distMat <- matrix(0L, nrow = ncol(pat.cpm), ncol = ncol(pat.cpm))
rownames(infer.distMat) <- c(colnames(pat.epiMR), colnames(pat.stromaMR)); colnames(infer.distMat) <- c(colnames(pat.epiMR), colnames(pat.stromaMR))
View(infer.distMat)
dim(pat.stromaMR)
i <- 1
j <- 1
pair.dist <- dist( rbind( predict.stroma[i,] , pat.stromaMR[,j] ) )
papair.dist
pair.dist
pair.dist1]
pair.dist[1]
infer.distMat <- matrix(0L, nrow = ncol(pat.cpm), ncol = ncol(pat.cpm))
rownames(infer.distMat) <- c(colnames(pat.epiMR), colnames(pat.stromaMR)); colnames(infer.distMat) <- c(colnames(pat.epiMR), colnames(pat.stromaMR))
for (i in 1:nrow(predict.stroma) ) {
e.Name <- rownames(predict.stroma)[i]
for (j in 1:ncol(pat.stromaMR) ) {
s.Name <- colnames(pat.stromaMR)[j]
pair.dist <- dist( rbind( predict.stroma[i,] , pat.stromaMR[,j] ) )[1]
infer.distMat[e.Name, s.Name] <- pair.dist
infer.distMat[s.Name, e.Name] <- pair.dist
}
}
dim(infer.distMat)
diag(infer.distMat)
sum(diag(infer.distMat))
dim(predict.stroma)
infer.distMat[60,59]
infer.distMat[60,60]
infer.distMat[60,61]
infer.distMat[60,60]
infer.distMat[61,60]
infer.distMat[59,60]
infer.distMat[61,62]
install.packages('ape')
library(ape)
complete.distMat <- as.dist( additive(infer.distMat) )
View(complete.distMat)
?as.dist
partial.distMat <- as.dist(infer.distMat)
partial.distMat[partial.distMat == 0] <- NA
partial.distMat
head(partial.distMat)
complete.distMat <- as.dist( additive(partial.distMat) )
## MDS to find 3D coordinates
library(MASS)
library(ggplot2)
mds.fit <- isoMDS(complete.distMat, k = 3)
View(as.data.frame(complete.distMat))
View(as.matrix(complete.distMat))
complete.distMat <- as.dist( ultrametric(partial.distMat) )
mds.fit <- isoMDS(complete.distMat, k = 3)
install.packages("scatterplot3d")
library("scatterplot3d")
mds.fit$points
scatterplot3d(mds.fit$points)
dev.off()
scatterplot3d(mds.fit$points)
compartment <- c(rep('epithelial', 60), rep('stromal', nrow(infer.distMat) - 60))
compartment
colors <- c('red', 'blue')[as.numeric(compartment)]
scatterplot3d(mds.fit$points, colors = colors, box = FALSE)
colors <- c(rep('red', 60), rep('blue', nrow(infer.distMat) - 60))
scatterplot3d(mds.fit$points, colors = colors, box = FALSE)
scatterplot3d(mds.fit$points, color = colors, box = FALSE)
plot.mat <- mds.fit$points
rownames(plot.mat) <- rownames(infer.distMat); colnames(plot.mat) <- c('MDS1', 'MDS2', 'MDS3')
compartment <- c(rep('epithelial', 60), rep('stromal', nrow(infer.distMat) - 60))
colors <- c(rep('red', 60), rep('blue', nrow(infer.distMat) - 60))
scatterplot3d(plot.mat, color = colors, box = FALSE)
scatterplot3d(plot.mat, color = colors, box = FALSE, pch = 16)
scatterplot3d(plot.mat * c(-1, -1, 1), color = colors, box = FALSE, pch = 16)
setwd('C://Users/lvlah/linux/ac_lab/single-cell-pipeline/')
source('functions/process-utils.R')
source('functions/cluster-functions.R')
source('functions/viper-utils.R')
library(ggplot2)
library(ggpubr)
library(viper)
library(pheatmap)
library(RColorBrewer)
raw.mat <- readRDS('tutorial/pbmc.rds')
filt.mat <- QCTransform(raw.mat)
cpm.mat <- CPMTransform(filt.mat)
rank.mat <- RankTransform(cpm.mat)
dat.mat <- rank.mat[,1:100]
## convert to entrez
convert.dict <- readRDS(paste(gtex.path, 'gene-convert-dict.rds', sep = ''))
dat.mat <- dat.mat[ which(rownames(dat.mat) %in% convert.dict$Ensembl.Gene.ID) ,] # remove rows with no ENSG match
rname.match <- match(rownames(dat.mat), convert.dict$Ensembl.Gene.ID) # match remaining ENSG names
entrez.names <- convert.dict$Entrez.Gene.ID[rname.match] # get Entrez names
na.inds <- which(is.na(entrez.names)) # remove NA entrez names from matrix
dat.mat <- dat.mat[ -na.inds ,]; entrez.names <- entrez.names[ -na.inds]
rownames(dat.mat) <- entrez.names
## load in all gtex networks
net.files <- dir(gtex.path, pattern = '*.rda')
gtex.nets <- list()
for (i in 1:length(net.files)) {
gtex.nets[[i]] <- get(load( paste(gtex.path, net.files[i], sep = '') ))
}
## compute VIPER for all the networks
viper.mats <- list()
for (i in 1:length(gtex.nets)) {
viper.mats[[i]] <- viper(dat.mat, gtex.nets[[i]], method = 'none')
}
gtex.path <- 'GTEx-Nets/'
## convert to entrez
convert.dict <- readRDS(paste(gtex.path, 'gene-convert-dict.rds', sep = ''))
dat.mat <- dat.mat[ which(rownames(dat.mat) %in% convert.dict$Ensembl.Gene.ID) ,] # remove rows with no ENSG match
rname.match <- match(rownames(dat.mat), convert.dict$Ensembl.Gene.ID) # match remaining ENSG names
entrez.names <- convert.dict$Entrez.Gene.ID[rname.match] # get Entrez names
na.inds <- which(is.na(entrez.names)) # remove NA entrez names from matrix
dat.mat <- dat.mat[ -na.inds ,]; entrez.names <- entrez.names[ -na.inds]
rownames(dat.mat) <- entrez.names
## load in all gtex networks
net.files <- dir(gtex.path, pattern = '*.rda')
gtex.nets <- list()
for (i in 1:length(net.files)) {
gtex.nets[[i]] <- get(load( paste(gtex.path, net.files[i], sep = '') ))
}
## compute VIPER for all the networks
viper.mats <- list()
for (i in 1:length(gtex.nets)) {
viper.mats[[i]] <- viper(dat.mat, gtex.nets[[i]], method = 'none')
}
?lapply
vip.mats <- viper.mats[1:3]
length(vip.mats)
dim(vip.mats[1])
dim(vip.mats[[1]])
dim(vip.mats[[2]])
dim(vip.mats[[3]])
# identify set of regulators and create final matrix
regs <- unique(Reduce(union, lapply(vip.mats, rownames)))
length(regs)
int.mat <- Matrix(0L, nrow = length(regs), ncol = ncol(vip.mats[[1]]))
int.mat <- matrix(0L, nrow = length(regs), ncol = ncol(vip.mats[[1]]))
i <- 1
regs[i]
regs[i] %in% rownames(vip.mats[[1]])
regs[i] %in% rownames(vip.mats[[2]])
regs[i] %in% rownames(vip.mats[[3]])
reg.mat <- lapply(vip.mats, function(x) {
if (regs[i] %in% rownames(x)) {
return( x[ regs[i] ,] )
} else {
return( rep(NA, ncol(x)) )
}
})
reg.mat
as.data.frame(reg.mat)
reg.mat <- as.data.frame( lapply(vip.mats, function(x) {
if (regs[i] %in% rownames(x)) {
return( x[ regs[i] ,] )
} else {
return( rep(NA, ncol(x)) )
}
} ) )
incl.vec <- which(!is.na(reg.mat[,1]))
incl.vec
incl.vec <- which(!is.na(reg.mat[1,]))
setdiff(rownames(vip.mats[[1]], vip.mats[[2]]))
setdiff(rownames(vip.mats[[1]]), rownames(vip.mats[[2]]))
which(regs == '190')
i <- 47
reg.mat <- as.data.frame( lapply(vip.mats, function(x) {
if (regs[i] %in% rownames(x)) {
return( x[ regs[i] ,] )
} else {
return( rep(NA, ncol(x)) )
}
} ) )
reg.mat
incl.vec <- which(!is.na(reg.mat[1,]))
incl.vec
regs <- unique(Reduce(union, lapply(vip.mats, rownames)))
int.mat <- matrix(0L, nrow = length(regs), ncol = ncol(vip.mats[[1]]))
rownames(int.mat) <- regs; colnames(int.mat) <- colnames(vip.mats[[1]])
# integrate each reg
for (i in 1:length(regs)) {
# generate matrix of all instances of this regulon
reg.mat <- as.data.frame( lapply(vip.mats, function(x) {
if (regs[i] %in% rownames(x)) {
return( x[ regs[i] ,] )
} else {
return( rep(NA, ncol(x)) )
}
} ) )
incl.vec <- which(!is.na(reg.mat[1,]))
# integrata
sInt <- rowSums( t(t(reg.mat[, incl.vec]) * weights[incl.vec]) ) / sqrt(sum(weights[incl.vec] ** 2))
int.mat[regs[i] ,] <- sInt
}
i <- 47
# generate matrix of all instances of this regulon
reg.mat <- as.data.frame( lapply(vip.mats, function(x) {
if (regs[i] %in% rownames(x)) {
return( x[ regs[i] ,] )
} else {
return( rep(NA, ncol(x)) )
}
} ) )
incl.vec <- which(!is.na(reg.mat[1,]))
# integrata
sInt <- rowSums( t(t(reg.mat[, incl.vec]) * weights[incl.vec]) ) / sqrt(sum(weights[incl.vec] ** 2))
weights <- rep(1, 3)
# integrata
sInt <- rowSums( t(t(reg.mat[, incl.vec]) * weights[incl.vec]) ) / sqrt(sum(weights[incl.vec] ** 2))
sInt
reg.mat
# identify set of regulators and create final matrix
regs <- unique(Reduce(union, lapply(vip.mats, rownames)))
int.mat <- matrix(0L, nrow = length(regs), ncol = ncol(vip.mats[[1]]))
rownames(int.mat) <- regs; colnames(int.mat) <- colnames(vip.mats[[1]])
# integrate each reg
for (i in 1:length(regs)) {
# generate matrix of all instances of this regulon
reg.mat <- as.data.frame( lapply(vip.mats, function(x) {
if (regs[i] %in% rownames(x)) {
return( x[ regs[i] ,] )
} else {
return( rep(NA, ncol(x)) )
}
} ) )
incl.vec <- which(!is.na(reg.mat[1,]))
# integrata
c.weights <- weights[incl.vec]
sInt <- rowSums( t(t(reg.mat[, incl.vec]) * c.weights) ) / sqrt(sum(c.weights ** 2))
int.mat[regs[i] ,] <- sInt
}
View(int.mat)
i <- 1
samp <- colnames(dat.mat)[i]
samp
net.mat <- as.data.frame(lapply(viper.mats, function(x) { x[, samp] }))
net.vects <- lapply(viper.mats, function(x) { x[, samp] })
net.vects
?rnorm
p.norm(1, lower.tail = FALSE)
pnorm(1, lower.tail = FALSE)
pnorm(2, lower.tail = FALSE)
pnorm(3, lower.tail = FALSE)
samp
vect <- viper.mats[[1]][, samp]
vect
vect <- pnorm(abs(vect), lower.tail = FALSE)
vect
L <- ncol(dat.mat)
L
1/L * 1/vect
hmpVal <- 1 / (1 / L) * (1 / vect)
hmpVal
hmpVal <- 1 / sum( (1/L) * (1/vect) )
hmpVal
samp <- colnames(dat.mat)[i]
r1.net <- readRDS('tutorial/pbmc_r1-net-pruned.rds')
r1.pAct <- viper(rank.mat, r1.net, method = 'none')
r1.viperDist <- as.dist(viperSimilarity(r1.pAct))
r1.clusts <- PamKRange(r1.viperDist, kmin = 2, kmax = 10)
r1.clustSil <- SilScoreEval(r1.clusts, r1.viperDist)
plot.dat <- data.frame('k' = 2:10, 'Silhouette.Scores' = r1.clustSil)
ggplot(plot.dat, aes(x = k, y = Silhouette.Scores)) + geom_point() + geom_line() +
ggtitle('R1 Clustering Silhouette Scores')
r1.clustMats <- MakeCMfA(filt.mat, r1.viperDist, clustering = r1.clusts$k3, out.dir = 'tutorial', out.name = 'pbmc-r1-clusts')
source('functions/viper-utils.R')
r1.clustMats <- MakeCMfA(filt.mat, r1.viperDist, clustering = r1.clusts$k3, out.dir = 'tutorial', out.name = 'pbmc-r1-clusts')
source('functions/viper-utils.R')
r1.clustMats <- MakeCMfA(filt.mat, r1.viperDist, clustering = r1.clusts$k3, out.dir = 'tutorial', out.name = 'pbmc-r1-clusts')
r1.clustMats <- MakeCMfA(filt.mat, r1.viperDist, clustering = r1.clusts$k3, out.dir = 'tutorial', out.name = 'pbmc-r1-clusts')
source('functions/viper-utils.R')
r1.clustMats <- MakeCMfA(filt.mat, r1.viperDist, clustering = r1.clusts$k3, out.dir = 'tutorial', out.name = 'pbmc-r1-clusts')
source('functions/process-utils.R')
source('functions/cluster-functions.R')
source('functions/viper-utils.R')
library(ggplot2)
library(ggpubr)
library(viper)
library(pheatmap)
library(RColorBrewer)
raw.mat <- readRDS('tutorial/pbmc.rds')
r1.clustMats <- MakeCMfA(filt.mat, r1.viperDist, clustering = r1.clusts$k3, out.dir = 'tutorial', out.name = 'pbmc-r1-clusts')
library(rmarkdown)
source('functions/process-utils.R')
source('functions/cluster-functions.R')
source('functions/viper-utils.R')
library(ggplot2)
library(ggpubr)
library(viper)
library(pheatmap)
library(RColorBrewer)
raw.mat <- readRDS('tutorial/pbmc.rds')
filt.mat <- QCTransform(raw.mat)
cpm.mat <- CPMTransform(filt.mat)
rank.mat <- RankTransform(cpm.mat)
# load in networks
c1.net <- readRDS('tutorial/pbmc-r2-c1_pruned.rds')
c2.net <- readRDS('tutorial/pbmc-r2-c2_pruned.rds')
c3.net <- readRDS('tutorial/pbmc-r2-c3_pruned.rds')
# infer protein activity
r2.pAct <- viper(rank.mat, list('c1' = c1.net, 'c2' = c2.net, 'c3' = c3.net), method = 'none')
render('PISCES_walkthrough.Rmd')
render('PISCES_walkthrough.Rmd')
render('PISCES_walkthrough.Rmd')
dat.umap <- cbcMR_UMAP(r2.pAct)
ClusterUMAP(r2.clusts$k2$clustering, dat.umap, 'R2 Clustering: k = 2')
render('PISCES_walkthrough.Rmd')
