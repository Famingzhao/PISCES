pheatmap(r1.pAct[markers,names(sort(phiVals[1,]))], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
?apply
?cor
# mr correlation
pAct.phiCorr <- apply(r1.pAct, 1, function(x) { cor(x, y = phiVals, method = 'spearman') }
# mr correlation
pAct.phiCorr <- apply(r1.pAct, 1, function(x) { cor(x, y = phiVals, method = 'spearman') })
# mr correlation
pAct.phiCorr <- apply(r1.pAct, 1, function(x) { cor(x, y = phiVals, method = 'spearman') })
dim(r1.pAct)
length(phiVals)
# mr correlation
pAct.phiCorr <- apply(r1.pAct, 1, function(x) { cor(x, y = phiVals[1,colnames(r1.pAct)], method = 'spearman') })
pAct.phiCorr
hist(pAct.phiCorr)
saveRDS(pAct.phiCorr, file = 'C://Users/lvlah/linux/ac_lab/data/cardoso_lung/car-lung_r1-phiCorr.rds')
?sort
pAct.phiCorr <- pAct.phiCorr[ names(sort(abs(pAct.phiCorr, decreasing = TRUE))) ]
pAct.phiCorr <- pAct.phiCorr[ names(sort(abs(pAct.phiCorr), decreasing = TRUE)) ]
head(pAct.phiCorr)
pAct.phiCorr[1:50]
annot.df <- data.frame('phi' = sort(phiVals[1,]))
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:50] , names(sort(phiVals[1,])) ], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
?pheatmap
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:75] , names(sort(phiVals[1,])) ], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize = 4,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
row.df <- data.frame('correlation' = pAct.phiCorr[1:50])
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:75] , names(sort(phiVals[1,])) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 4,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
row.df <- data.frame('correlation' = abs(pAct.phiCorr[1:50]))
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:75] , names(sort(phiVals[1,])) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 4,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
annot.df <- data.frame('phi' = sort(phiVals[1,]))
row.df <- data.frame('corr' = abs(pAct.phiCorr[1:50]))
pheatmap(r1.pAct[ names(pAct.phiCorr)[1:75] , names(sort(phiVals[1,])) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 4,
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
annot.df <- data.frame('clust' = as.factor(r1.clust$k2$clustering[names(sort(phiVals[1,]))]),
'phi' = sort(phiVals[1,]))
pheatmap(r1.pAct[markers,names(sort(phiVals[1,]))], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
annot.df <- data.frame('clust' = as.factor(r1.clust$k2$clustering[names(sort(phiVals[1,]))]),
'phi' = sort(phiVals[1,]))
pheatmap(r1.pAct[markers,names(sort(phiVals[1,]))], scale = 'row', annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
stroma.net <- get(load('C://Users/lvlah/linux/ac_lab/data/lcm_pda/regul_stroma.rda'))
stroma.net.pruned <- pruneRegulon(stroma.net, 50, adaptive = FALSE, eliminate = TRUE)
epi.net <- get(load('C://Users/lvlah/linux/ac_lab/data/lcm_pda/regul_epith.rda'))
epi.net.pruned <- pruneRegulon(epi.net, 50, adaptive = FALSE, eliminate = TRUE)
hugo.names <- readRDS("C://Users/lvlah/linux/ac_lab/Hugo.Names.rds")
############################
stroma.mrs <- readRDS('C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_stroma_msViper.rds')
epi.mrs <- readRDS('C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_epi_msViper.rds')
stroma.vip <- readRDS('C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_stroma_viper.rds')
epi.vip <- readRDS('C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_epi_viper.rds')
metadata <- read.table('C://Users/lvlah/linux/ac_lab/data/lcm_pda/PDAC-Interactome-Samples_newOk.txt',
header = TRUE, sep = '\t')
############################
### generate correlation model(s) between stroma and epi compartments in lcm ###
## sync up IDs
stroma.patients <- metadata$PatientID[ match(colnames(stroma.vip), metadata$SampleID) ]
epi.patients <- metadata$PatientID[ match(colnames(epi.vip), metadata$SampleID) ]
shared.patients <- intersect(stroma.patients, epi.patients)
stroma.meta <- metadata[ which(metadata$Compartment == 'Stroma') ,]
matched.stromaID <- stroma.meta$SampleID[ match(shared.patients, stroma.meta$PatientID) ]
epi.meta <- metadata[ which(metadata$Compartment == 'Epithelium') ,]
matched.epiID <- epi.meta$SampleID[ match(shared.patients, epi.meta$PatientID) ]
length(matched.stromaID)
length(matched.epiID)
stroma.vip <- stroma.vip[, as.character(matched.stromaID) ]
epi.vip <- epi.vip[, as.character(matched.epiID) ]
## change to hugo gene names
rownames(stroma.vip) <- hugo.names[ rownames(stroma.vip) ]
rownames(epi.vip) <- hugo.names[ rownames(epi.vip) ]
## create the design matrix for the MMR model
stroma.MRmat <- stroma.vip[ intersect(names(sort(stroma.mrs$es$nes, decreasing = TRUE))[1:100], rownames(stroma.vip)) ,]
rownames(stroma.MRmat) <- paste('S.', rownames(stroma.MRmat), sep = '')
epi.MRmat <- epi.vip[ intersect(names(sort(epi.mrs$es$nes, decreasing = TRUE))[1:100], rownames(epi.vip)) ,]
rownames(epi.MRmat) <- paste('E.', rownames(epi.MRmat), sep = '')
design.mat <- rbind( stroma.MRmat , epi.MRmat )
design.mat <- t(design.mat)
## fit MMR model
dvs <- paste(colnames(design.mat)[1:100], collapse = ' + ')
ivs <- paste(colnames(design.mat)[101:ncol(design.mat)], collapse = ' + ')
model.formula <- as.formula(colnames(design.mat)[1:100] ~ ivs)
mmr.model <- lm(design.mat[, 1:100] ~ design.mat[, 101:ncol(design.mat)])
saveRDS(mmr.model, 'C://Users/lvlah/linux/ac_lab/tumor_geom/lcm_model_fit.rds')
### find single-cell distances using the bulk linear model ###
sc.pda <- readRDS('C://Users/lvlah/linux/ac_lab/data/singleCell/all/pdac-allPatients-geneExp.rds')
sc.metaData <- read.csv('C://Users/lvlah/linux/ac_lab/data/singleCell/all/metadata.csv', header = TRUE, row.names = 1)
View(sc.metaData)
ht150.samps <- rownames(sc.metaData)[which(sc.metaData$ID == 'HT150')]
ht150.samps
table(scsc.metaData$ID)
table(sc.metaData$ID)
ht150.samps <- rownames(sc.metaData)[which(sc.metaData$ID == 'HT143')]
ht143.pda <- sc.pda[, ht143.samps]
ht143.samps <- rownames(sc.metaData)[which(sc.metaData$ID == 'HT143')]
ht143.pda <- sc.pda[, ht143.samps]
dim(ht143.samps)
dim(ht143.pda
)
patient <- 'HT103'
pat.samps <- rownames(sc.metaData)[which(sc.metaData$ID == patient)]
pat.pda <- sc.pda[, pat.samps]
rm(ht143.pda)
dim(pat.pda)
## split the matrix into epithelial and stromal compartments
pat.eCells <- get(load('C://Users/lvlah/linux/ac_lab/data/cancerCellNames/names_cancer_cells_PDA_103.rda'))
ppat.eCells
pat.eCells
### find single-cell distances using the bulk linear model ###
source('C://Users/lvlah/linux/ac_lab/single-cell-pipeline/functions/process-utils.R')
QCPlots(pat.pda)
pat.filt <- QCTransform(pat.pda)
pat.cpm <- CPMTransform(pat.filt)
pat.epi <- pat.cpm[, intersect(pat.eCells, colnames(pat.cpm)) ]
dim(pat.epi)
length(pat.eCells)
pat.stroma <- pat.cpm[, setdiff(colnames(pat.cpm), pat.eCells) ]
dim(pat.stroma)
pat.epiRank <- RankTransform(pat.epi)
pat.stromaRank <- RankTransform(pat.stroma)
pat.epiVip <- viper(pat.epiRank, regulon = epi.net.pruned, method = 'none')
pat.stromaVip <- viper(pat.stromaRank, regulon = stroma.net.pruned, method = 'none')
rownames(pat.epiRank)
rownames(stroma.vip)
epi.net.pruned
names(epi.net.pruned)
convert.dict <- readRDS('C://Users/lvlah/linux/ac_lab/data/gene-convert-dict.rds')
View(convert.dict)
length(which(rownames(sc.pda) %in% convert.dict$Entrez.Gene.ID))
rownames(sc.pda)
length(which(rownames(sc.pda) %in% convert.dict$Ensembl.Gene.ID))
length(which(rownames(pat.cpm) %in% convert.dict$Ensembl.Gene.ID))
dim(pat.cpm)
## convert gene names to entrez
pat.cpm <- pat.cpm[ which(rownames(pat.cpm) %in% convert.dict$Ensembl.Gene.ID) ,]
dim(pat.cpm)
match(rownames(pat.cpm), convert.dict$Ensembl.Gene.ID)
rownames(pat.cpm) <- convert.dict$Entrez.Gene.ID[ match(rownames(pat.cpm), convert.dict$Ensembl.Gene.ID) ]
rownames(pat.cpm)
pat.cpm <- pat.cpm[ which(rownames(pat.cpm) %in% convert.dict$Ensembl.Gene.ID) ,]
rownames(pat.cpm) <- convert.dict$Entrez.Gene.ID[ match(rownames(pat.cpm), convert.dict$Ensembl.Gene.ID) ]
## split the matrix into epithelial and stromal compartments
pat.eCells <- get(load('C://Users/lvlah/linux/ac_lab/data/cancerCellNames/names_cancer_cells_PDA_103.rda'))
pat.epi <- pat.cpm[, intersect(pat.eCells, colnames(pat.cpm)) ]
pat.stroma <- pat.cpm[, setdiff(colnames(pat.cpm), pat.eCells) ]
pat.epiRank <- RankTransform(pat.epi)
pat.stromaRank <- RankTransform(pat.stroma)
## viper inference using bulk networks
pat.epiVip <- viper(pat.epiRank, regulon = epi.net.pruned, method = 'none')
pat.stromaVip <- viper(pat.stromaRank, regulon = stroma.net.pruned, method = 'none')
pat.cpm <- CPMTransform(pat.filt)
## convert gene names to entrez
pat.cpm <- pat.cpm[ which(rownames(pat.cpm) %in% convert.dict$Ensembl.Gene.ID) ,]
rownames(pat.cpm) <- convert.dict$Entrez.Gene.ID[ match(rownames(pat.cpm), convert.dict$Ensembl.Gene.ID) ]
## split the matrix into epithelial and stromal compartments
pat.eCells <- get(load('C://Users/lvlah/linux/ac_lab/data/cancerCellNames/names_cancer_cells_PDA_103.rda'))
pat.epi <- pat.cpm[, intersect(pat.eCells, colnames(pat.cpm)) ]
pat.stroma <- pat.cpm[, setdiff(colnames(pat.cpm), pat.eCells) ]
pat.epiRank <- RankTransform(pat.epi)
pat.stromaRank <- RankTransform(pat.stroma)
## viper inference using bulk networks
pat.epiVip <- viper(pat.epiRank, regulon = epi.net.pruned, method = 'none')
pat.stromaVip <- viper(pat.stromaRank, regulon = stroma.net.pruned, method = 'none')
## subset scVip matrices to MRs from LCM
pat.epiMR <- pat.epiVip[ rownames(stroma.MRmat) ,]
rownames(pat.stromaVip) <- hugo.names[ rownames(pat.stromaVip) ]
rownames(pat.epiVip) <- hugo.names[ rownames(pat.epiVip) ]
## subset scVip matrices to MRs from LCM
pat.epiMR <- pat.epiVip[ rownames(stroma.MRmat) ,]
dim(pat.epiVip)
intersect(rownames(stroma.MRmat), rownames(pat.epiVip))
rownames(stroma.MRmat)
rownames(pat.stromaVip) <- paste('S', rownames(pat.stromaVip), sep = '.')
rownames(pat.epiVip) <- paste('E', rownames(pat.epiVip), sep = '.')
rownames(pat.stromaVip)
intersect(rownames(stroma.MRmat), rownames(pat.epiVip))
intersect(rownames(stroma.MRmat), rownames(pat.stromaVip))
pat.stromaMR <- pat.stromaVip[ rownames(stroma.MRmat) ,]
pat.epiMR <- pat.epiVip[ rownames(epi.MRmat) ,]
## predict using the LCM MMR model
predict.stroma <- predict(mmr.model, t(pat.epiMR))
## predict using the LCM MMR model
predict.stroma <- predict(mmr.model, as.data.frame(t(pat.epiMR)) )
mmr.model
as.data.frame(t(pat.epiMR))
dim(as.data.frame(t(pat.epiMR)))
mmrmmr.model
mmr.model
dim(mmr.model$coefficients)
?predict
## predict using the LCM MMR model
predict.stroma <- predict(mmr.model, newdata = as.data.frame(t(pat.epiMR)) )
## predict using the LCM MMR model
predict.stroma <- predict.lm(mmr.model, newdata = as.data.frame(t(pat.epiMR)) )
?fitted
fitted(mmr.model)
View(mmr.model$coefficients)
cbind( as.matrix(rep(1, ncol(pat.epiMR))) , t(pat.epiMR) )
View(cbind( as.matrix(rep(1, ncol(pat.epiMR))) , t(pat.epiMR) ))
## predict using the LCM MMR model
predict.stroma <- cbind( as.matrix(rep(1, ncol(pat.epiMR))) , t(pat.epiMR) ) %*% as.matrix( mmr.model$coefficients )
dim(predict.stroma)
rownames(predict.stroma) <- colnames( pat.epiMR )
colnames(predict.stroma) <- rownames( mmr.model$coefficients )
View(predict.stroma)
colnames(predict.stroma) <- colnames( mmr.model$coefficients )
View(predict.stroma)
## infer pairwise distances
infer.distMat <- matrix(0L, nrow = ncol(pat.cpm), ncol = ncol(pat.cpm))
rownames(infer.distMat) <- c(colnames(pat.epiMR), colnames(pat.stromaMR)); colnames(infer.distMat) <- c(colnames(pat.epiMR), colnames(pat.stromaMR))
View(infer.distMat)
dim(pat.stromaMR)
i <- 1
j <- 1
pair.dist <- dist( rbind( predict.stroma[i,] , pat.stromaMR[,j] ) )
papair.dist
pair.dist
pair.dist1]
pair.dist[1]
infer.distMat <- matrix(0L, nrow = ncol(pat.cpm), ncol = ncol(pat.cpm))
rownames(infer.distMat) <- c(colnames(pat.epiMR), colnames(pat.stromaMR)); colnames(infer.distMat) <- c(colnames(pat.epiMR), colnames(pat.stromaMR))
for (i in 1:nrow(predict.stroma) ) {
e.Name <- rownames(predict.stroma)[i]
for (j in 1:ncol(pat.stromaMR) ) {
s.Name <- colnames(pat.stromaMR)[j]
pair.dist <- dist( rbind( predict.stroma[i,] , pat.stromaMR[,j] ) )[1]
infer.distMat[e.Name, s.Name] <- pair.dist
infer.distMat[s.Name, e.Name] <- pair.dist
}
}
dim(infer.distMat)
diag(infer.distMat)
sum(diag(infer.distMat))
dim(predict.stroma)
infer.distMat[60,59]
infer.distMat[60,60]
infer.distMat[60,61]
infer.distMat[60,60]
infer.distMat[61,60]
infer.distMat[59,60]
infer.distMat[61,62]
install.packages('ape')
library(ape)
complete.distMat <- as.dist( additive(infer.distMat) )
View(complete.distMat)
?as.dist
partial.distMat <- as.dist(infer.distMat)
partial.distMat[partial.distMat == 0] <- NA
partial.distMat
head(partial.distMat)
complete.distMat <- as.dist( additive(partial.distMat) )
## MDS to find 3D coordinates
library(MASS)
library(ggplot2)
mds.fit <- isoMDS(complete.distMat, k = 3)
View(as.data.frame(complete.distMat))
View(as.matrix(complete.distMat))
complete.distMat <- as.dist( ultrametric(partial.distMat) )
mds.fit <- isoMDS(complete.distMat, k = 3)
install.packages("scatterplot3d")
library("scatterplot3d")
mds.fit$points
scatterplot3d(mds.fit$points)
dev.off()
scatterplot3d(mds.fit$points)
compartment <- c(rep('epithelial', 60), rep('stromal', nrow(infer.distMat) - 60))
compartment
colors <- c('red', 'blue')[as.numeric(compartment)]
scatterplot3d(mds.fit$points, colors = colors, box = FALSE)
colors <- c(rep('red', 60), rep('blue', nrow(infer.distMat) - 60))
scatterplot3d(mds.fit$points, colors = colors, box = FALSE)
scatterplot3d(mds.fit$points, color = colors, box = FALSE)
plot.mat <- mds.fit$points
rownames(plot.mat) <- rownames(infer.distMat); colnames(plot.mat) <- c('MDS1', 'MDS2', 'MDS3')
compartment <- c(rep('epithelial', 60), rep('stromal', nrow(infer.distMat) - 60))
colors <- c(rep('red', 60), rep('blue', nrow(infer.distMat) - 60))
scatterplot3d(plot.mat, color = colors, box = FALSE)
scatterplot3d(plot.mat, color = colors, box = FALSE, pch = 16)
scatterplot3d(plot.mat * c(-1, -1, 1), color = colors, box = FALSE, pch = 16)
setwd('C://Users/lvlah/linux/ac_lab/single-cell-pipeline/')
library(rmarkdown)
render('PISCES_walkthrough.Rmd')
dat.mat <- rank.mat[,1:100]
gtex.path <- 'GTEx-Nets/'
dir(gtex.path, pattern = '*.rda')
nets <- c()
for (i in 1:length(net.files)) {
nets <- c(nets, get(load(paste(gtex.path, net.files[i], sep = ''))))
}
## load in all gtex networks
net.files <- dir(gtex.path, pattern = '*.rda')
nets <- c()
for (i in 1:length(net.files)) {
nets <- c(nets, get(load(paste(gtex.path, net.files[i], sep = ''))))
}
nets[1]
dim(nets)
length(nets)
## load in all gtex networks
net.files <- dir(gtex.path, pattern = '*.rda')
gtex.nets <- list()
rm(nets)
for (i in 1:length(net.files)) {
gtex.nets[[i]] <- get(load( paste(gtex.path, net.files[i], sep = '') ))
}
dim(gtex.nets)
lenght(gtex.nets)
length(gtex.nets)
rownames(dat.mat)
source('functions/process-utils.R')
source('functions/process-utils.R')
## convert to entrez
dat.mat <- Ensemble2Entrez(dat.mat)
## convert to entrez
convert.dict <- readRDS(paste(gtex.path, 'gene-convert-dict.rds', sep = ''))
View(convert.dict)
rownames(dat.mat)
dim(dat.mat)
length(which(rownames(dat.mat) %in% convert.dict$Ensembl.Gene.ID))
which(rownames(dat.mat) %in% convert.dict$Ensembl.Gene.ID)
dat.mat <- dat.mat[ which(rownames(dat.mat) %in% convert.dict$Ensembl.Gene.ID) ,] # remove rows with no ENSG match
rname.match <- match(rownames(dat.mat), convert.dict$Ensembl.Gene.ID)
rname.match
enrez.names <- convert.dict$Entrez.Gene.ID[rname.match] # get Entrez names
entrez.names <- convert.dict$Entrez.Gene.ID[rname.match] # get Entrez names
length(which(is.na(entrez.names)))
entrez.names <- convert.dict$Entrez.Gene.ID[rname.match] # get Entrez names
na.inds <- which(is.na(entrez.names)) # remove NA entrez names from matrix
dat.mat <- dat.mat[ -na.inds ,]; entrez.names <- entrez.names[ -na.inds]
dim(dat.mat)
length(entrez.names)
rownames(dat.mat) <- entrez.names
rownames(dat.mat)
## compute VIPER for all the networks
viper.mats <- list()
for (i in 1:length(gtex.nets)) {
viper.mats[[i]] <- viper(dat.mat, gtex.nets[[i]], method = 'none')
}
length(viper.mats)
dim(viper.mats[[1]])
## identify the three most important networks
net.counts <- rep(0, length(gtex.nets)); names(net.counts) <- 1:length(gtex.nets)
shared.regs <- Reduce(intersect, lapply(viper.mats, rownames))
shared.regs
reg <- shared.regs[1]
lapply(viper.mats, function(x) { x[reg,] })
as.data.frame(lapply(viper.mats, function(x) { x[reg,] }))
reg.mat <- as.data.frame(lapply(viper.mats, function(x) { x[reg,] }))
dim(reg.mat)
which.max(c(1,2,6,3,8,2))
?apply
max.inds <- apply(reg.mat, 1, which.max)
max.inds
reg.mat[1,]
rownames(reg.mat) <- 1:46
rownames(reg.mat) <- 1:36
colnames(reg.mat) <- 1:36
reg.mat[1,]
max.inds <- apply(reg.mat, 1, function(x) { which.max(abs(x)) } )
max.inds
reg.mat[2,]
for (j in 1:length(max.inds)) {
net.counts[ max.inds[j] ] <- net.counts[ max.inds[j] ] + 1
}
net.counts
table(max.inds)
net.counts <- rep(0, length(gtex.nets)); names(net.counts) <- 1:length(gtex.nets)
shared.regs <- Reduce(intersect, lapply(viper.mats, rownames))
for (i in 1:length(shared.regs)) {
reg <- shared.regs[i]
reg.mat <- as.data.frame(lapply(viper.mats, function(x) { x[reg,] }))
max.inds <- apply(reg.mat, 1, function(x) { which.max(abs(x)) } )
for (j in 1:length(max.inds)) {
net.counts[ max.inds[j] ] <- net.counts[ max.inds[j] ] + 1
}
}
net.counts
net.counts <- sort(net.counts, decreasing = TRUE)
top.nets <- names(net.counts)[1:num.nets]
num.nets <- 3
top.nets <- names(net.counts)[1:num.nets]
top.nets
net.counts
## integrate the results of the three selected networks
top.vip <- viper.mats[top.nets]
length(top.vip)
length(gtex.nets[top.nets])
## integrate the results of the three selected networks
mVip.mat <- viper(dat.mat, regulon = gtex.nets[top.nets], method = 'none')
gtex.nets[[top.nets]]
top.nets
gtex.nets[top.nets]
top.nets <- as.numeric(names(net.counts)[1:num.nets])
top.nets
gtex.nets[top.nets]
length(gtex.nets(top.nets))
length(gtex.nets[top.nets])
class(gtex.nets[top.nets][1])
class(gtex.nets[top.nets][[1]])
class(gtex.nets[[top.nets]][[1]])
class(gtex.nets[[top.nets]])
## integrate the results of the three selected networks
mVip.mat <- viper(dat.mat, regulon = gtex.nets[top.nets], method = 'none')
dim(mVip.mat)
mVip.mat <- mVip.mat[ which(rownames(mVip.mat) %in% convert.dict$Entrez.Gene.ID) ,]
rname.match <- match(rownames(mVip.mat), convert.dict$Entrez.Gene.ID)
ensg.names <- convert.dict$Ensembl.Gene.ID[rname.match]
na.inds <- which(is.na(ensg.names))
mVip.mat <- mVip.mat[ -na.inds ]; ensg.names <- ensg.names[ -na.inds ]
rownames(mVip.mat) <- ensg.names
## integrate the results of the three selected networks
mVip.mat <- viper(dat.mat, regulon = gtex.nets[top.nets], method = 'none')
which(rownames(mVip.mat) %in% convert.dict$Entrez.Gene.ID)
dim(mVip.mat)
## convert to ensemble
mVip.mat <- mVip.mat[ which(rownames(mVip.mat) %in% convert.dict$Entrez.Gene.ID) ,]
dim(mVip.mat)
rname.match <- match(rownames(mVip.mat), convert.dict$Entrez.Gene.ID)
rname.match
ensg.names <- convert.dict$Ensembl.Gene.ID[rname.match]
ensg.names
na.inds <- which(is.na(ensg.names))
na.inds
na.inds <- which(ensg.names == '')
na.inds
mVip.mat <- mVip.mat[ -na.inds ,]; ensg.names <- ensg.names[ -na.inds ]
rownames(mVip.mat) <- ensg.names
dim(mVip.mat)
dat.mat <- rank.mat[,1:100]
gtex.vip <- GTExVIPER(dat.mat, 'GTEx-Nets/')
#' Performs VIPER analysis with all the GTEx Networks, then identifies and uses the top set for a metaVIPER analysis.
#'
#' @param dat.mat Gene expression signature in matrix format (genes X samples) with ENSG ids.
#' @param gtex.path Path to the directory containing the GTEx networks.
#' @param num.nets Number of top networks to use. Default of 3.
#' @return A metaVIPER integration of the VIPER results for the top num.nets of GTEx networks (proteins X samples).
GTExVIPER <- function(dat.mat, gtex.path, num.nets = 3) {
## convert to entrez
convert.dict <- readRDS(paste(gtex.path, 'gene-convert-dict.rds', sep = ''))
dat.mat <- dat.mat[ which(rownames(dat.mat) %in% convert.dict$Ensembl.Gene.ID) ,] # remove rows with no ENSG match
rname.match <- match(rownames(dat.mat), convert.dict$Ensembl.Gene.ID) # match remaining ENSG names
entrez.names <- convert.dict$Entrez.Gene.ID[rname.match] # get Entrez names
na.inds <- which(is.na(entrez.names)) # remove NA entrez names from matrix
dat.mat <- dat.mat[ -na.inds ,]; entrez.names <- entrez.names[ -na.inds]
rownames(dat.mat) <- entrez.names
## load in all gtex networks
net.files <- dir(gtex.path, pattern = '*.rda')
gtex.nets <- list()
for (i in 1:length(net.files)) {
gtex.nets[[i]] <- get(load( paste(gtex.path, net.files[i], sep = '') ))
}
## compute VIPER for all the networks
viper.mats <- list()
for (i in 1:length(gtex.nets)) {
viper.mats[[i]] <- viper(dat.mat, gtex.nets[[i]], method = 'none')
}
## identify the most important networks (as defined by num.nets)
net.counts <- rep(0, length(gtex.nets)); names(net.counts) <- 1:length(gtex.nets)
shared.regs <- Reduce(intersect, lapply(viper.mats, rownames))
for (i in 1:length(shared.regs)) {
reg <- shared.regs[i]
reg.mat <- as.data.frame(lapply(viper.mats, function(x) { x[reg,] }))
max.inds <- apply(reg.mat, 1, function(x) { which.max(abs(x)) } )
for (j in 1:length(max.inds)) {
net.counts[ max.inds[j] ] <- net.counts[ max.inds[j] ] + 1
}
}
net.counts <- sort(net.counts, decreasing = TRUE)
top.nets <- as.numeric(names(net.counts)[1:num.nets])
## clean up for memory purposes
rm(viper.mats)
## integrate the results of the three selected networks
mVip.mat <- viper(dat.mat, regulon = gtex.nets[top.nets], method = 'none')
## convert to ensemble
mVip.mat <- mVip.mat[ which(rownames(mVip.mat) %in% convert.dict$Entrez.Gene.ID) ,]
rname.match <- match(rownames(mVip.mat), convert.dict$Entrez.Gene.ID)
ensg.names <- convert.dict$Ensembl.Gene.ID[rname.match]
na.inds <- which(ensg.names == '')
mVip.mat <- mVip.mat[ -na.inds ,]; ensg.names <- ensg.names[ -na.inds ]
rownames(mVip.mat) <- ensg.names
## return
return(mVip.mat)
}
gtex.vip <- GTExVIPER(dat.mat, 'GTEx-Nets/')
dim(gtex.vip)
View(gtex.vip)
source('functions/viper-utils.R')
library(rmarkdown)
render('PISCES_walkthrough.Rmd')
