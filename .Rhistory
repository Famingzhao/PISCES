> l.mrs <- BTTestMRs(r2.pAct, lClust)
Tue Jun 18 11:09:32 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:34 2019
Tue Jun 18 11:09:34 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:38 2019
Tue Jun 18 11:09:38 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:40 2019
Tue Jun 18 11:09:40 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:42 2019
Tue Jun 18 11:09:42 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:45 2019
Tue Jun 18 11:09:45 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:48 2019
Tue Jun 18 11:09:48 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:51 2019
Tue Jun 18 11:09:51 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:53 2019
Tue Jun 18 11:09:53 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:56 2019
Tue Jun 18 11:09:56 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:09:59 2019
Tue Jun 18 11:09:59 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:10:01 2019
Tue Jun 18 11:10:01 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%
Tue Jun 18 11:10:05 2019
Tue Jun 18 11:10:05 2019
Computing the bootstrapped signatures by 2 permutations.
|=============================================================================================================================================================================================| 100%\
l.mrs
filt.mat <- QCTransform(raw.mat)
cpm.mat <- CPMTransform(filt.mat)
rank.mat <- RankTransform(cpm.mat)
VIPIntegrate <- function(vip.mats, weights) {
# set weights, if not specified
if (missing(weights)) {
weights <- rep(1, length(vip.mats))
}
# identify set of regulators and create final matrix
regs <- unique(Reduce(union, lapply(vip.mats, rownames)))
int.mat <- matrix(0L, nrow = length(regs), ncol = ncol(vip.mats[[1]]))
rownames(int.mat) <- regs; colnames(int.mat) <- colnames(vip.mats[[1]])
# integrate each reg
for (i in 1:length(regs)) {
# generate matrix of all instances of this regulon
reg.mat <- as.data.frame( lapply(vip.mats, function(x) {
if (regs[i] %in% rownames(x)) {
return( x[ regs[i] ,] )
} else {
return( rep(NA, ncol(x)) )
}
} ) )
incl.vec <- which(!is.na(reg.mat[1,]))
# integrata
c.weights <- weights[incl.vec]
sInt <- rowSums( t(t(reg.mat[, incl.vec]) * c.weights) ) / sqrt(sum(c.weights ** 2))
int.mat[regs[i] ,] <- sInt
}
# return
return(int.mat)
}
dat.mat <- rank.mat[,1:100]
gtex.path <- 'GTEx-Nets/'
num.nets <- 3
L <- ncol(dat.mat)
## convert to entrez
convert.dict <- readRDS(paste(gtex.path, 'gene-convert-dict.rds', sep = ''))
dat.mat <- dat.mat[ which(rownames(dat.mat) %in% convert.dict$Ensembl.Gene.ID) ,] # remove rows with no ENSG match
rname.match <- match(rownames(dat.mat), convert.dict$Ensembl.Gene.ID) # match remaining ENSG names
entrez.names <- convert.dict$Entrez.Gene.ID[rname.match] # get Entrez names
na.inds <- which(is.na(entrez.names)) # remove NA entrez names from matrix
dat.mat <- dat.mat[ -na.inds ,]; entrez.names <- entrez.names[ -na.inds]
rownames(dat.mat) <- entrez.names
## load in all gtex networks
net.files <- dir(gtex.path, pattern = '*.rda')
gtex.nets <- list()
for (i in 1:length(net.files)) {
gtex.nets[[i]] <- get(load( paste(gtex.path, net.files[i], sep = '') ))
}
## compute VIPER for all the networks
viper.mats <- list()
for (i in 1:length(gtex.nets)) {
viper.mats[[i]] <- viper(dat.mat, gtex.nets[[i]], method = 'none')
}
names(viper.mats) <- 1:length(viper.mats)
## sample specific network selection and viper integration
net.weights <- matrix(0L, nrow = length(viper.mats), ncol = L)
for (i in 1:ncol(dat.mat)) {
samp <- colnames(dat.mat)[i]
net.ints <- lapply(viper.mats, function(x) {
vect <- x[, samp]
vect <- pnorm(abs(vect), lower.tail = FALSE)
hmpVal <- 1 / mean(1/vect)
})
net.ints <- unlist(net.ints)
net.ints <- net.ints / sum(net.ints)
net.weights[,i] <- net.ints
}
## identify all regs for integation
reg.union <- unique(unlist(lapply(viper.mats, rownames)))
mvip.mat <- matrix(0L, nrow = length(reg.union), ncol = L)
rownames(mvip.mat) <- reg.union; colnames(mvip.mat) <- colnames(dat.mat)
## integrate based on weights
for (i in 1:L) {
samp <- colnames(dat.mat)[i]
samp.weights <- net.weights[,i]; names(samp.weights) <- 1:length(samp.weights)
samp.weights <- sort(samp.weights, decreasing = TRUE)
samp.mats <- viper.mats[names(samp.weights[1:num.nets])]
samp.mats <- lapply(samp.mats, function(x) { as.matrix(x[,samp], ncol = 1) } )
mvip.vect <- VIPIntegrate(samp.mats, samp.weights[1:num.nets])
mvip.mat[rownames(mvip.vect) , samp] <- mvip.vect
}
dim(mvip.mat)
library(rmarkdown)
render('PISCES_walkthrough.Rmd')
render('PISCES_walkthrough.Rmd')
render('PISCES_walkthrough.Rmd')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
r2.cbcUMAP
r2.cbcUMAP$layout
plot.dat <- data.frame('UMAP1' = r2.cbcUMAP$layout[,1], 'UMAP2' = r2.cbcUMAP$layout[,2], 'Clusters' = r2.louvain)
ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(color = Clusters), alpha=0.5, size = 2) +
theme(panel.background = element_blank(), legend.justification = c("right", "top")) +
ggtitle("Viper Clusters")
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
ClusterHeatmap(r2.pAct[ MR_UnWrap(cluster.MRs, top = 10) , ], clust = r2.louvain, plotTitle = 'Louvain Viper Clustering Master Regulators')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
saveRDS(cluster.MRs, 'tutorial/pbmc_r2-MRs.rds')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
ClusterHeatmap(r2.pAct[ MR_UnWrap(r2.MRs, top = 10) , ], clust = r2.louvain, plotTitle = 'Louvain Viper Clustering Master Regulators')
source('functions/cluster-functions.R')
ClusterHeatmap(r2.pAct[ MR_UnWrap(r2.MRs, top = 10) , ], clust = r2.louvain, plotTitle = 'Louvain Viper Clustering Master Regulators')
source('functions/cluster-functions.R')
ClusterHeatmap(r2.pAct[ MR_UnWrap(r2.MRs, top = 10) , ], clust = r2.louvain, plotTitle = 'Louvain Viper Clustering Master Regulators')
ClusterHeatmap(r2.pAct[ MR_UnWrap(r2.MRs, top = 10) , ], clust = r2.louvain, plotTitle = 'Louvain Viper Clustering Master Regulators')
ClusterHeatmap(r2.pAct[ MR_UnWrap(r2.MRs, top = 10) , ], clust = r2.louvain, plotTitle = 'Louvain Viper Clustering Master Regulators')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
render('PISCES_walkthrough.Rmd', output_format = 'word_document')
source('C://Users/lvlah/linux/ac_lab/single-cell-pipeline/functions/process-utils.R')
source('C://Users/lvlah/linux/ac_lab/single-cell-pipeline/functions/cluster-functions.R')
source('C://Users/lvlah/linux/ac_lab/single-cell-pipeline/functions/viper-utils.R')
nc.pAct <- readRDS('C://Users/lvlah/linux/ac_lab/data/cardoso_lung/car-lung_noContam-pAct.rds')
nc.vipDist <- readRDS('C://Users/lvlah/linux/ac_lab/data/cardoso_lung/car-lung_noContam-vipDist.rds')
nc.vipDist <- as.dist(nc.vipDist)
nc.pam <- PamKRange(nc.vipDist, kmin = 2, kmax = 5)
nc.pamSil <- SilScoreEval(nc.pam, nc.vipDist)
nc.pamSil
nc.cbcMR <- CBCMRs(nc.cbcMR)
nc.cbcMR <- CBCMRs(nc.pAct)
nc.cbcUMAP <- CustomUMAP(nc.pAct[ nc.cbcMR ,])
nc.louvain <- LouvainClust(nc.pAct[ nc.cbcMR ,])
plot.dat <- data.frame('UMAP1' = nc.cbcUMAP$layout[,1], 'UMAP2' = nc.cbcUMAP$layout[,2], 'Clusters' = nc.louvain)
ggplot(plot.dat, aes(UMAP1, UMAP2)) + geom_point(aes(color = Clusters), alpha=0.5, size = 2) +
theme(panel.background = element_blank(), legend.justification = c("right", "top")) +
ggtitle("Viper Clusters")
markers <- c('Cldn10', 'Cdkn1c', 'Sox2', 'Bmp4', 'Sox9',
'Foxp2', 'Etv5', 'Irx1', 'S100a6', 'Ctnnd2',
'Epha4')
annot.df <- data.frame('Louvain' = as.factor(sort(nc.louvain)))
pheatmap(nc.pAct[ markers , names(sort(nc.louvain)) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Louvain Clustering')
pheatmap(nc.pAct[ markers , names(sort(nc.louvain)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Louvain Clustering')
nc.pam$k2$silinfo
nc.pam$k2$silinfo$widths[,3]
annot.df <- data.frame('PAM' = as.factor(sort(nc.pam$k2$clustering)), 'SilScore' = nc.pam$k2$silinfo$widths[,3][ names(sort(nc.pam$k2$clustering)) ])
pheatmap(nc.pAct[ markers , names(sort(nc.pam$k2$clustering)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Louvain Clustering')
annot.df <- data.frame('PAM' = as.factor(sort(nc.pam$k2$clustering)), 'SilScore' = nc.pam$k2$silinfo$widths[,3][ names(sort(nc.pam$k2$clustering)) ],
'Louvain' = as.factor(nc.louvain[ names(sort(nc.pam$k2$clustering)) ]))
pheatmap(nc.pAct[ markers , names(sort(nc.pam$k2$clustering)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Louvain Clustering')
library(pca3d)
library(cluster)
library(viper)
library(ggplot2)
library(pheatmap)
library(RColorBrewer)
source('C://Users/lvlah/linux/ac_lab/code/algs/multiwayKMeans.R')
c1.center <- rowMeans(nc.pAct[, which(nc.pam$k2$clustering == 1) ])
c2.center <- rowMeans(nc.pAct[, which(nc.pam$k2$clustering == 2) ])
k2.centers <- cbind(c1.center, c2.center)
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
phiVal <- nc.mwk2[[1]]
phiVal
dim(phiVal)
phiVal <- nc.mwk2[[1]][1,]
phiVal
annot.df <- data.frame('phi' = sort(phiVal), 'PAM' = as.factor(nc.pam$k2$clustering)[ names(sort(phiVal)) ])
pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
annot.df <- data.frame('phi' = sort(phiVal), 'PAM' = as.factor(nc.pam$k2$clustering)[ names(sort(phiVal)) ])
pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
hist(phiVal)
annot.df <- data.frame('phi' = sort(phiVal), 'PAM' = as.factor(nc.pam$k2$clustering)[ names(sort(phiVal)) ])
pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
source('C://Users/lvlah/linux/ac_lab/code/algs/multiwayKMeans.R')
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
source('C://Users/lvlah/linux/ac_lab/code/algs/multiwayKMeans.R')
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
source('C://Users/lvlah/linux/ac_lab/code/algs/multiwayKMeans.R')
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
?`solve,?solveCHMfactor,diagonalMatrix-method`
?solve
?inv
??inv
library(Matrix)
?inv
?solve
source('C://Users/lvlah/linux/ac_lab/code/algs/multiwayKMeans.R')
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
source('C://Users/lvlah/linux/ac_lab/code/algs/multiwayKMeans.R')
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
dim(nc.pAct)
source('C://Users/lvlah/linux/ac_lab/code/algs/multiwayKMeans.R')
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
dim(centers)
dim(k2.centers)
source('C://Users/lvlah/linux/ac_lab/code/algs/multiwayKMeans.R')
nc.mwk2 <- Cluster(nc.pAct, k2.centers)
phiVal <- nc.mwk2[[1]][1,]
annot.df <- data.frame('phi' = sort(phiVal), 'PAM' = as.factor(nc.pam$k2$clustering)[ names(sort(phiVal)) ])
pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
hist(phi)
hist(phiVal)
annot.df <- data.frame('phi' = sort(phiVal), 'PAM' = as.factor(nc.pam$k2$clustering)[ names(sort(phiVal)) ])
pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 12,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
x <- t(nc.pAct)
y <- as.double(as.matrix(phiVal))
cv.lasso <- cv.glmnet(x, y, type.measure = 'auc', standardize = TRUE)
plot(cv.lasso)
plot(cv.lasso$glmnet.fit, xvar="lambda", label=TRUE)
cv.lasso$lambda.min
cv.lasso$lambda.1se
coef(cv.lasso, s=cv.lasso$lambda.min)
fit.coefs <- coef(cv.lasso, s=cv.lasso$lambda.min)
fit.coefs <- as.matrix(fit.coefs)[, 1]
fit.coefs <- fit.coefs[-1]
fit.coefs <- fit.coefs[ names(sort(abs(fit.coefs), decreasing = TRUE)) ]
library(glmnet)
x <- t(nc.pAct)
y <- as.double(as.matrix(phiVal))
cv.lasso <- cv.glmnet(x, y, type.measure = 'auc', standardize = TRUE)
plot(cv.lasso)
plot(cv.lasso$glmnet.fit, xvar="lambda", label=TRUE)
cv.lasso$lambda.min
cv.lasso$lambda.1se
coef(cv.lasso, s=cv.lasso$lambda.min)
fit.coefs <- coef(cv.lasso, s=cv.lasso$lambda.min)
fit.coefs <- as.matrix(fit.coefs)[, 1]
fit.coefs <- fit.coefs[-1]
fit.coefs <- fit.coefs[ names(sort(abs(fit.coefs), decreasing = TRUE)) ]
numMR <- 50
numMR <- 50
annot.df <- data.frame('phi' = sort(phiVal), 'PAM' = as.factor(nc.pam$k2$clustering)[ names(sort(phiVal)) ])
row.df <- data.frame('coeff' = abs(fit.coefs[1:numMR]))
pheatmap(nc.pAct[ names(fit.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
pheatmap(nc.pAct[ names(fit.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
mod.y <- -4*phiVal^2 + 4*phiVal
mod.lasso <- cv.glmnet(x, mod.y, type.measure = 'auc', standardize = TRUE)
mod.coefs <- coef(mod.lasso, s=mod.lasso$lambda.min)
mod.coefs <- as.matrix(mod.coefs)[, 1]
mod.coefs <- mod.coefs[-1]
mod.coefs <- mod.coefs[ names(sort(abs(mod.coefs), decreasing = TRUE)) ]
numMR <- 50
annot.df <- data.frame('phi' = sort(phiVal), 'PAM' = as.factor(nc.pam$k2$clustering)[ names(sort(phiVal)) ])
row.df <- data.frame('coeff' = abs(mod.coefs[1:numMR]))
pheatmap(nc.pAct[ names(mod.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
pheatmap(nc.pAct[ names(mod.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis: Modified Phi')
markers.phearmap <- pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 12,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
phi.pheatmap <- pheatmap(nc.pAct[ names(fit.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis')
modphi.pheatmap <- pheatmap(nc.pAct[ names(mod.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K-Means Analysis: Modified Phi')
markers.pheatmap <- pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 12,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
print(annotate_figure(phi.plot, top = text_grab('MRs Identified by LASSO', size = 24)))
print(annotate_figure(phi.plot, top = text_grob('MRs Identified by LASSO', size = 24)))
phi.plot <- ggarrange(markers.pheatmap, phi.pheatmap)
par(mfrow=c(1, 2))
markers.pheatmap <- pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 12,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = 'Multiway K Means Clustering')
par(mfrow=c(1, 2))
markers
markers.pheatmap
phi.pheatmap
mtext("MRs Identified by LASSO", side=3, outer=TRUE, line=-3)
plot.list.1 <- list(markers.pheatmap, phi.pheatmap)
g <- do.call(grid.arrange, plot_list)
library(ggpubr)
g <- do.call(grid.arrange, plot_list)
library(grid)
g <- do.call(grid.arrange, plot_list)
??grid.arrange
library(ggpubr)
?grid.arrange
g <- do.call(grid.arrange, plot_list)
g <- grid.arrange(plot.list.1)
install.packages('gridExtra')
library(gridExtra)
g <- grid.arrange(plot.list.1)
plot.list.1 <- list(markers.pheatmap[[4]], phi.pheatmap[[4]])
g <-do.call(grid.arrange, plot.list.1)
print(annotate_figure(g, top = text_grob('MRs Identified by LASSO', size = 24)))
modphi.pheatmap <- pheatmap(nc.pAct[ names(mod.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE)
phi.pheatmap <- pheatmap(nc.pAct[ names(fit.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE)
library(pheatmap)
library(ggpubr)
markers.pheatmap <- pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 12,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE)
library(RColorBrewer)
markers.pheatmap <- pheatmap(nc.pAct[ markers , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 12,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE)
phi.pheatmap <- pheatmap(nc.pAct[ names(fit.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE)
modphi.pheatmap <- pheatmap(nc.pAct[ names(mod.coefs)[1:numMR] , names(sort(phiVal)) ], scale = 'row',
annotation_col = annot.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100), fontsize_row = 6,
cluster_rows = TRUE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE)
plot.list.1 <- list(markers.pheatmap[[4]], phi.pheatmap[[4]])
g <-do.call(grid.arrange, plot.list.1)
print(annotate_figure(g, top = text_grob('MRs Identified by LASSO', size = 24)))
?annota_figure
?annotate_figure
print(annotate_figure(g, top = text_grob('MRs Identified by LASSO w/ modified Phi', size = 16, family = "Arial")))
g <- annotate_figure(g, top = text_grob('MRs Identified by LASSO w/ modified Phi', size = 16, family = "Arial"))
plot.list.1 <- list(markers.pheatmap[[4]], phi.pheatmap[[4]])
g <- do.call(grid.arrange, plot.list.1)
g <- annotate_figure(g, top = text_grob('MRs Identified by LASSO', size = 16, family = "Arial"))
?ggsave
plot.list.1 <- list(markers.pheatmap[[4]], phi.pheatmap[[4]])
g <- do.call(grid.arrange, plot.list.1)
g <- annotate_figure(g, top = text_grob('MRs Identified by LASSO', size = 16, family = "Arial"))
ggsave('C://Users/lvlah/linux/ac_lab/data/cardoso_lung/mwkm_lasso_pheatmap.jpeg', plot = g, width = 10, height = 20)
plot.list.2 <- list(markers.pheatmap[[4]], modphi.pheatmap[[4]])
g <-do.call(grid.arrange, plot.list.1)
g <- annotate_figure(g, top = text_grob('MRs Identified by LASSO w/ modified Phi', size = 16, family = "Arial"))
ggsave('C://Users/lvlah/linux/ac_lab/data/cardoso_lung/mwkm_mod-lasso_pheatmap.jpeg', plot = g, width = 10, height = 20)
plot.list.2 <- list(markers.pheatmap[[4]], modphi.pheatmap[[4]])
g <-do.call(grid.arrange, plot.list.2)
g <- annotate_figure(g, top = text_grob('MRs Identified by LASSO w/ modified Phi', size = 16, family = "Arial"))
ggsave('C://Users/lvlah/linux/ac_lab/data/cardoso_lung/mwkm_mod-lasso_pheatmap.jpeg', plot = g, width = 10, height = 20)
saveRDS(nc.pam, file = 'C://Users/lvlah/linux/ac_lab/data/cardoso_lung/nc_pam-clusts.rds')
saveRDS(nc.louvain, file = 'C://Users/lvlah/linux/ac_lab/data/cardoso_lung/nc_louvain-clust.rds')
saveRDS(nc.mwk2, file = 'C://Users/lvlah/linux/ac_lab/data/cardoso_lung/nc_mwk2.rds')
saveRDS(cv.lasso, file = 'C://Users/lvlah/linux/ac_lab/data/cardoso_lung/nc_phi-lasso.rds')
saveRDS(mod.lasso, file = 'C://Users/lvlah/linux/ac_lab/data/cardoso_lung/nc_mod-phi-lasso.rds')
rank.mat <- readRDS('C://Users/lvlah/linux/ac_lab/data/cardoso_lung/car-lung_rank.rds')
nc.rank <- rank.mat[, rownames(nc.pAct)]
length(intersect(rownames(nc.pAct), rownames(rank.mat)))
dim(nc.pAct)
dim(rank.mat)
head(rownames(nc.pAct))
length(intersect(colnames(nc.pAct), colnames(rank.mat)))
nc.rank <- rank.mat[, colnames(nc.pAct)]
saveRDS(nc.rank, file = 'C://Users/lvlah/linux/ac_lab/data/cardoso_lung/nc_rank.rds')
noContam.net <- readRDS('C://Users/lvlah/linux/ac_lab/data/cardoso_lung/car-lung_noContam_pruned.rds')
head(rownames(nc.pAct))
#' Generates a pheatmap of the targets of a specific regulator.
#'
#' @param net The ARACNe network containing the regulon you'd like to visualize.
#' @param gene.sig A gene expression signature - typically the one used as input to VIPER (samples X genes).
#' @param protein The name of the protein you'd like to visualize. Ensure that you are using the same naming convetion as the network you are trying to visualzie.
#' @param annot.df Annotation vector for the samples. For instance, a named vector of phi values.
RegulonViz <- function(net, gene.sig, protein, annot.df) {
# pull the regulon out of the network and form an annotation data frame
regulon <- net[[protein]]
tfm <- regulon$tfmode
like <- regulon$likelihood[order(tfm)]
tfm <- sort(tfm)
edges <- names(tfm)
row.df <- data.frame('tf.mode' = tfm, 'likelihood' = like)
# generate a heatmap
pheat.mat <- gene.sig[intersect(edges, rownames(gene.sig)), names(annot.df)]
pheatmap(pheat.mat, scale = 'row', annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = paste('Regulon Viz: ', protein, sep = ''))
}
RegulonViz(noContam.net, nc.rank, 'Aatf', annot.df)
head(annot.df)
#' Generates a pheatmap of the targets of a specific regulator.
#'
#' @param net The ARACNe network containing the regulon you'd like to visualize.
#' @param gene.sig A gene expression signature - typically the one used as input to VIPER (samples X genes).
#' @param protein The name of the protein you'd like to visualize. Ensure that you are using the same naming convetion as the network you are trying to visualzie.
#' @param annot.df Annotation vector for the samples. For instance, a named vector of phi values.
RegulonViz <- function(net, gene.sig, protein, annot.df) {
# pull the regulon out of the network and form an annotation data frame
regulon <- net[[protein]]
tfm <- regulon$tfmode
like <- regulon$likelihood[order(tfm)]
tfm <- sort(tfm)
edges <- names(tfm)
row.df <- data.frame('tf.mode' = tfm, 'likelihood' = like)
# generate a heatmap
pheat.mat <- gene.sig[intersect(edges, rownames(gene.sig)), rownames(annot.df)]
pheatmap(pheat.mat, scale = 'row', annotation_col = annot.df, annotation_row = row.df,
color = colorRampPalette(rev(brewer.pal(10, 'RdBu')))(100),
cluster_rows = FALSE, cluster_cols = FALSE, show_colnames = FALSE, show_rownames = TRUE,
main = paste('Regulon Viz: ', protein, sep = ''))
}
RegulonViz(noContam.net, nc.rank, 'Aatf', annot.df)
